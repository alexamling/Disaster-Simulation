// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel LoadBaseMap
#pragma kernel GenerateHeatMap
#pragma kernel GenerateFireMap

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> FireMap; 
RWTexture2D<float> HeatMap; // shows the heat generated from that frame of the firemap
RWTexture2D<float> FuelMap;
RWTexture2D<float> WaterMap;


Texture2D<float4> FirePattern;
Texture2D<float> HeightMap;
Texture2D<float> BaseFuelMap;

float4 FireData[32]; // x pos, y pos, scale, intensity
int NumFires;

float2 WindOffset;
float WindStrength;

[numthreads(8,8,1)]
void LoadBaseMap(uint3 id : SV_DispatchThreadID)
{
	uint w, h;
	FirePattern.GetDimensions(w, h);

	float4 Fires = { 0,0,0,0 };

	for (int i = 0; i < NumFires; i++) {
		int3 position = { FireData[i].x * FireData[i].z - (w * .5), FireData[i].y * FireData[i].z - (h * .5), 0};
		Fires = Fires + (FirePattern[(id.xy * FireData[i].z) - position.xy] * FireData[i].w);
	}
	
	FireMap[id.xy] = (Fires + FireMap[id.xy]) *.99;
}

[numthreads(8, 8, 1)]
void GenerateHeatMap(uint3 id : SV_DispatchThreadID)
{
	float baseHeight = 1 - HeightMap[id.xy];

	float heightDif;

	// sample neighboring coordinates, scale based off of the change in heightmap
	float value = FireMap[id.xy];
	heightDif = baseHeight + (HeightMap[float2(id.x, id.y + 1)]);
	value += FireMap[float2(id.x, id.y + 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x, id.y - 1)]);
	value += FireMap[float2(id.x, id.y - 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x + 1, id.y)]);
	value += FireMap[float2(id.x + 1, id.y)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x - 1, id.y)]);
	value += FireMap[float2(id.x - 1, id.y)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x + 1, id.y + 1)]);
	value += FireMap[float2(id.x + 1, id.y + 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x + 1, id.y - 1)]);
	value += FireMap[float2(id.x + 1, id.y - 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x - 1, id.y + 1)]);
	value += FireMap[float2(id.x - 1, id.y + 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;

	heightDif = baseHeight + (HeightMap[float2(id.x - 1, id.y - 1)]);
	value += FireMap[float2(id.x - 1, id.y - 1)] * heightDif * heightDif * heightDif * heightDif * heightDif * heightDif;
	value *= .005f;

	// TODO: Adjust value based on moisture map
	value -= WaterMap[id.xy] * WaterMap[id.xy] * .001;
	WaterMap[id.xy] -= value;

	// add heat value and adjust for fuelmap
	HeatMap[id.xy] = ((value + HeatMap[id.xy]) * FuelMap[id.xy]);// -.000025;

	// alter fuelmap
	FuelMap[id.xy] -= value * .15 + .001;
}

[numthreads(8, 8, 1)]
void GenerateFireMap(uint3 id : SV_DispatchThreadID)
{
	float value = HeatMap[id.xy] * saturate(.5 - WindStrength);
	value += HeatMap[float2(id.x - WindOffset.x, id.y - WindOffset.y)] * WindStrength;
	value += FireMap[id.xy];
	value *= FuelMap[id.xy] + .955;
	FireMap[id.xy] = float4(value, value, value, 0);
}
